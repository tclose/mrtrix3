#!/usr/bin/env python

# Script that performs B1 field inhomogeneity correction for a DWI volume series
# Bias field is estimated using the mean b=0 image, and subsequently used to correct all volumes


import os, sys
import lib.app

from lib.binaryInPath  import binaryInPath
from lib.errorMessage  import errorMessage
from lib.getFSLSuffix  import getFSLSuffix
from lib.getHeaderInfo import getHeaderInfo
from lib.isWindows     import isWindows
from lib.runCommand    import runCommand

lib.app.author = 'Robert E. Smith (robert.smith@florey.edu.au)'
lib.app.initCitations([ 'fast', 'FSL', 'N4' ])
lib.app.initParser('Perform B1 field inhomogeneity correction for a DWI volume series')
lib.app.parser.add_argument('input',  help='The input image series to be corrected')
lib.app.parser.add_argument('output', help='The output corrected image series')
lib.app.parser.add_argument('-mask', help='Manually provide a mask image for bias field estimation')
lib.app.parser.add_argument('-bias', help='Output the estimated bias field')
algorithms = lib.app.parser.add_mutually_exclusive_group(required=True)
algorithms.add_argument('-ants', action='store_true', default=False, help='Use ANTS N4 to estimate the inhomogeneity field')
algorithms.add_argument('-fsl', action='store_true', default=False, help='Use FSL FAST to estimate the inhomogeneity field')
grad_import_group = lib.app.parser.add_mutually_exclusive_group()
grad_import_group.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
grad_import_group.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
lib.app.initialise()

if lib.app.args.fsl:

  if isWindows():
    errorMessage('Script cannot run using FSL on Windows due to FSL dependency')

  fsl_path = os.environ.get('FSLDIR', '')
  if not fsl_path:
    errorMessage('Environment variable FSLDIR is not set; please run appropriate FSL configuration script')

  fast_cmd = 'fast'
  if not binaryInPath(fast_cmd):
    fast_cmd = 'fsl5.0-fast'
    if not binaryInPath(fast_cmd):
      errorMessage('Could not find FSL program fast; please verify FSL install')
    
  fsl_suffix = getFSLSuffix()
  if fast_cmd == 'fast':
    fast_suffix = fsl_suffix
  else:
    fast_suffix = '.nii.gz'

elif lib.app.args.ants:

  if not binaryInPath('N4BiasFieldCorrection'):
    errorMessage('Could not find ANTS program N4BiasFieldCorrection; please check installation')

else:
  errorMessage('No bias field estimation algorithm specified')

grad_import_option = ''
if lib.app.args.grad:
  grad_import_option = ' -grad ' + lib.app.args.grad
elif lib.app.args.fslgrad:
  grad_import_option = ' -fslgrad ' + lib.app.args.fslgrad[0] + ' ' + lib.app.args.fslgrad[1]

lib.app.checkOutputFile(lib.app.args.output)
lib.app.checkOutputFile(lib.app.args.bias)

runCommand('mrconvert ' + lib.app.args.input + ' ' + os.path.join(lib.app.tempDir, 'in.mif') + grad_import_option)
if lib.app.args.mask:
  runCommand('mrconvert ' + lib.app.args.mask + ' ' + os.path.join(lib.app.tempDir, 'mask.nii') + ' -stride +1,+2,+3')

lib.app.gotoTempDir()

# Make sure it's actually a DWI that's been passed
dwi_sizes = getHeaderInfo('in.mif', 'size').split()
if len(dwi_sizes) != 4:
  errorMessage('Input image must be a 4D image')
DW_scheme = getHeaderInfo('in.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(dwi_sizes[3]):
  errorMessage('Input image does not contain valid DW gradient scheme')

# Generate a brain mask if required, or check the mask if provided
if lib.app.args.mask:
  mask_sizes = getHeaderInfo('mask.nii', 'size').split()
  if not mask_sizes[:3] == dwi_sizes[:3]:
    errorMessage('Provided mask image does not match input DWI')
else:
  runCommand('dwi2mask in.mif - | mrconvert - mask.nii -stride +1,+2,+3')

# Make a NiFTI image since this is what the external softwares need
runCommand('dwiextract in.mif bzeros.mif -bzero')
bzero_sizes = getHeaderInfo('bzeros.mif', 'size')
if len(bzero_sizes.split()) == 4:
  runCommand('mrmath bzeros.mif mean - -axis 3 | mrconvert - mean_bzero.nii -stride +1,+2,+3')
else:
  runCommand('mrconvert bzeros.mif mean_bzero.nii -stride +1,+2,+3')

if lib.app.args.fsl:
  # FAST doesn't accept a mask input; therefore need to explicitly mask the input image
  runCommand('mrcalc mean_bzero.nii mask.nii -mult mean_bzero_masked.nii')
  runCommand(fast_cmd + ' -t 2 -o fast -n 3 -b mean_bzero_masked.nii')
  bias_path = 'fast_bias' + fast_suffix
elif lib.app.args.ants:
  # Use the brain mask as a weights image rather than a mask; means that voxels at the edge of the mask
  #   will have a smoothly-varying bias field correction applied, rather than multiplying by 1.0 outside the mask
  bias_path = 'bias.nii'
  runCommand('N4BiasFieldCorrection -d 3 -i mean_bzero.nii -w mask.nii -o [corrected.nii,' + bias_path + '] -s 2 -b [150] -c [200x200,0.0]')
  
runCommand('mrcalc in.mif ' + bias_path + ' -div result.mif')
runCommand('mrconvert result.mif ' + os.path.join(lib.app.workingDir, lib.app.args.output) + lib.app.mrtrixForce)
if lib.app.args.bias:
  runCommand('mrconvert ' + bias_path + ' ' + os.path.join(lib.app.workingDir, lib.app.args.bias) + lib.app.mrtrixForce)
lib.app.complete()

